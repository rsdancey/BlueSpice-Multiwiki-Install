#!/bin/bash

# BlueSpice Wiki Initialization Script
# Complete setup wizard for new BlueSpice wiki instances

set -euo pipefail

# Script directory and paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Source logging functions
# shellcheck disable=SC1091
source "${SCRIPT_DIR}/lib/logging.sh"
# Ensure SCRIPT_DIR is correctly resolved
if [[ ! -d "$SCRIPT_DIR" ]]; then
    echo "Error: Could not determine script directory" >&2
    exit 1
fi
WIKIS_DIR="$(dirname "${SCRIPT_DIR}")/wikis"
TEMPLATE_DIR="${SCRIPT_DIR}/wiki-template"

# Debug: Show resolved paths (can be removed later)
if [[ "${DEBUG:-}" == "true" ]]; then
    echo "DEBUG: SCRIPT_DIR = $SCRIPT_DIR"
    echo "DEBUG: WIKIS_DIR = $WIKIS_DIR"
    echo "DEBUG: TEMPLATE_DIR = $TEMPLATE_DIR"
fi

# Default values - must be set before sourcing libraries
WIKI_NAME=""
WIKI_DOMAIN=""
WIKI_LANG="en"
SETUP_MODE=""
SKIP_DIRECTORY_SETUP=false
SSL_ENABLED=false
SMTP_HOST=""
SMTP_PORT="587"
SMTP_USER=""
SMTP_PASS=""

# Source modular libraries with error checking
for lib in validation config docker-utils oauth-config init-settings-config; do
    lib_path="${SCRIPT_DIR}/lib/${lib}.sh"
    if [[ ! -f "$lib_path" ]]; then
        echo "Error: Required library not found: $lib_path" >&2
        exit 1
    fi
    # shellcheck disable=SC1090
    source "$lib_path"
done

# Colors for output
# shellcheck disable=SC2034  # Colors may be used by sourced logging functions
RED='\033[0;31m'
# shellcheck disable=SC2034
GREEN='\033[0;32m'
# shellcheck disable=SC2034
YELLOW='\033[1;33m'
# shellcheck disable=SC2034
BLUE='\033[0;34m'
# shellcheck disable=SC2034
NC='\033[0m' # No Color

# Logging functions


# Help function
show_help() {
    cat << 'HELP'
BlueSpice Wiki Initialization Wizard
======================================

SYNOPSIS:
    ./initialize-wiki [OPTIONS]

DESCRIPTION:
    Interactive setup wizard for creating new BlueSpice wiki instances.
    Supports fresh installations, backup restoration, and automatic email configuration.

OPTIONS:
    -h, --help          Show this help message and exit

FEATURES:
    • Automated wiki directory setup and environment configuration
    • SSL certificate management with Let's Encrypt integration
    • Intelligent SMTP email configuration with auto-detection
    • Database user creation with secure socket connections
    • Backup restoration with optional image import support
    • Multi-language support (en, de, fr, es, it, pt, nl, pl, ru, ja, zh)
    • Automatic maintenance script installation (sendTestEmail.php)
    • Email configuration validation and prompting

EMAIL CONFIGURATION:
    • Automatic detection of missing SMTP configuration
    • Interactive prompting for incomplete email settings
    • Validation of SMTP hosts, passwords, and settings
    • Support for Office 365, Gmail, and custom SMTP servers
    • Proper MediaWiki email variable configuration ($wgPasswordSender, etc.)
    • Built-in email testing functionality

DATABASE CONNECTIVITY:
    • Unique database users per wiki instance (e.g., wikiname_user)
    • Socket-based connections for optimal performance
    • Automatic password generation and synchronization
    • Secure localhost database access

SSL CERTIFICATES:
    • Automatic Let's Encrypt certificate generation and renewal
    • Certificate expiry monitoring (warns when <30 days remaining)
    • HTTPS redirection and security headers
    • Domain validation and DNS checking

MAINTENANCE SCRIPTS:
    • Automatic installation of sendTestEmail.php for email testing
    • Pre-configured email permissions for users and autoconfirmed users
    • Built-in SMTP configuration validation tools

POST-INSTALLATION:
    After successful setup, your wiki will be accessible at:
    • HTTPS: https://your-domain.com (recommended with SSL)
    • HTTP: http://your-domain.com (fallback without SSL)

    Initial admin credentials are saved in the wiki directory.

MANAGEMENT COMMANDS:
    Start wiki:     ./bluespice-deploy-wiki --wiki-name=NAME --domain=DOMAIN
    Stop wiki:      docker compose -f /core/wikis/NAME/docker-compose.yml down
    Update wiki:    ./bluespice-deploy-wiki --wiki-name=NAME --run-update
    Test email:     docker exec bluespice-NAME-wiki-web php /app/bluespice/w/maintenance/sendTestEmail.php --to=email@domain.com

EXAMPLES:
    ./initialize-wiki                    # Interactive setup mode
    ./initialize-wiki --help            # Show this help message
    
    # Email testing examples:
    docker exec bluespice-Projects-wiki-web php /app/bluespice/w/maintenance/sendTestEmail.php \
        --to="user@example.com" --subject="Test Email"
    
    docker exec bluespice-Projects-wiki-web php /app/bluespice/w/maintenance/sendTestEmail.php \
        --to="user@example.com" --from="wiki@domain.com" --subject="Custom Sender Test"

FILES AND DIRECTORIES:
    /core/wikis/WIKI_NAME/              # Wiki instance directory
    /core/wikis/WIKI_NAME/.env          # Environment configuration
    /core/wikis/WIKI_NAME/pre-init-settings.php   # MediaWiki pre-initialization settings
    /core/wikis/WIKI_NAME/post-init-settings.php  # MediaWiki post-initialization settings
    /core/wikis/WIKI_NAME/initialAdminPassword     # Generated admin password

REQUIREMENTS:
    • Docker and Docker Compose installed and running
    • BlueSpice shared services (database, proxy) running
    • Network connectivity for SSL certificate generation
    • Valid domain name pointing to server (for SSL)

TROUBLESHOOTING:
    • If email configuration is incomplete, the script will automatically prompt
    • Use sendTestEmail.php to verify SMTP configuration
    • Check logs: docker logs bluespice-WIKI_NAME-wiki-web
    • Verify services: docker ps | grep bluespice

For detailed documentation, see README.md or visit the BlueSpice documentation.
HELP
}


# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
        esac
    done
}
# Certificate expiry checking (keeping existing function)
create_environment_file() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    log_info "Creating environment file with configuration..."
    
    # Ensure wiki directory exists
    if [[ ! -d "$wiki_dir" ]]; then
        log_error "Wiki directory does not exist: $wiki_dir"
        return 1
    fi
    
    # Use the new configuration management
    if ! save_configuration "$wiki_dir"; then
        log_error "Failed to create environment configuration"
        return 1
    fi
    
    log_info "Environment file created successfully"
}

# =============================================================================
# Configure Email Functions
# =============================================================================

check_and_prompt_email_config() {
    local env_file="$1"
    local smtp_host smtp_user smtp_pass
    
    if [[ -f "$env_file" ]]; then
        smtp_host=$(grep "^SMTP_HOST=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_user=$(grep "^SMTP_USER=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_pass=$(grep "^SMTP_PASS=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        
        # If any email config is missing, prompt for it
        if [[ -z "$smtp_host" || -z "$smtp_user" || -z "$smtp_pass" ]]; then
            echo "Email configuration incomplete in .env file."
            echo "Missing SMTP configuration detected. Please provide email settings:"
            echo
            configure_smtp
            
            # Update the .env file with new SMTP settings
            sed -i "s/^SMTP_HOST=.*/SMTP_HOST=${SMTP_HOST}/" "$env_file"
            sed -i "s/^SMTP_PORT=.*/SMTP_PORT=${SMTP_PORT}/" "$env_file"
            sed -i "s/^SMTP_USER=.*/SMTP_USER=${SMTP_USER}/" "$env_file"
            sed -i "s/^SMTP_PASS=.*/SMTP_PASS=${SMTP_PASS}/" "$env_file"
        fi
    fi
}

# Wiki directory setup
setup_wiki_directory() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    echo "Setting up wiki directory: $wiki_dir"
    mkdir -p "$wiki_dir"
    
    if [[ "$SETUP_MODE" == "restore" ]]; then
        echo "Preparing directory for backup restoration..."
        # Copy essential files only
        cp "${TEMPLATE_DIR}/docker-compose."* "$wiki_dir/"
    else
        echo "Copying template files..."
        cp -r "${TEMPLATE_DIR}/"* "$wiki_dir/"
    fi
    
    echo "Wiki directory prepared"
}

# Wiki deployment with improved OAuth extension handling
deploy_wiki_instance() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    log_info "Deploying wiki instance..."
    
    cd "$wiki_dir"
    
    # Deploy with fresh installation
    if ! "${SCRIPT_DIR}/bluespice-deploy-wiki" \
        --wiki-name="$WIKI_NAME" \
        --fresh-install; then
        log_error "Wiki deployment failed"
        exit 1
    fi
    
    # Wait for container to be fully ready before installing extensions
    log_info "Waiting for wiki container to be ready..."
    if ! wait_for_container_ready "$WIKI_NAME" 60; then
        log_error "Container failed to become ready - OAuth extensions cannot be installed"
        log_warn "You may need to install OAuth extensions manually later"
        return 0
    fi

    # Install and configure OAuth extensions using the new modular system
    log_info "Setting up OAuth extensions..."
    # need post-init-settings file here
    if ! setup_oauth_extensions "$WIKI_NAME" "$wiki_dir" "$WIKI_DOMAIN"; then
        log_error "CRITICAL: OAuth extension setup failed"
        log_warn "Wiki is functional but OAuth authentication will not work"
        log_warn "Manual intervention may be required"
        return 1
    fi
    
    log_info "OAuth extension setup completed successfully"
}

# SSL setup
setup_ssl() {
    if [[ "$SETUP_MODE" == "ssl" ]] || [[ "$SSL_ENABLED" == "true" ]]; then
        echo "SSL certificate will be automatically generated by Let's Encrypt"
        echo "This may take a few minutes..."
    fi
    return 0
}

# Backup restoration function using proper MediaWiki maintenance approach
restore_from_backup() {
    local backup_file="$1"
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    echo "Starting backup restoration using MediaWiki maintenance system..."
    
    # Check if backup file exists
    if [[ ! -f "$backup_file" ]]; then
        echo "Error: Backup file not found: $backup_file" >&2
        return 1
    fi
    
    # Determine file type and prepare for restoration
    local file_ext="${backup_file##*.}"
    local temp_sql="/tmp/restore_backup.sql"
    
    echo "Preparing backup file for restoration..."
    
    # Handle different file formats
    case "$file_ext" in
        "gz")
            echo "Decompressing gzip file..."
            if ! gunzip -c "$backup_file" > "$temp_sql"; then
                echo "Error: Failed to decompress backup file" >&2
                return 1
            fi
            ;;
        "sql")
            echo "Using SQL file directly..."
            cp "$backup_file" "$temp_sql"
            ;;
        *)
            echo "Error: Unsupported backup file format. Supported: .sql, .sql.gz" >&2
            return 1
            ;;
    esac
    
    # Check if it is a SQL dump (not XML)
    if head -5 "$temp_sql" | grep -q "MySQL dump\|MariaDB dump\|-- Dump completed"; then
        echo "Detected SQL database dump - using database restoration method"
        
        echo "Restoring database from SQL dump using smart importer..."
        
        # Use smart database importer with prefix detection
        local smart_importer="$SCRIPT_DIR/smart_db_import.sh"
        
        
        if [[ ! -f "$smart_importer" ]]; then
            echo "Error: Smart database importer not found at: $smart_importer" >&2
            return 1
        fi
        
        # Set up environment for smart importer
        export WIKI_DIR="$wiki_dir"
        export SQL_FILE="$temp_sql"
        
        # Call the smart importer script
        if "$smart_importer" "$temp_sql"; then
            echo "✓ Database restored successfully using smart importer"
        else
            echo "Error: Smart database import failed" >&2
            return 1
        fi
        
    elif head -5 "$temp_sql" | grep -q "<mediawiki\|<siteinfo"; then
        echo "Detected MediaWiki XML dump - using importDump.php"
        
        # Copy XML file to wiki container
        if ! docker_copy_to_container "$WIKI_NAME" "$temp_sql" "/tmp/restore.xml"; then
            echo "Error: Failed to copy XML dump to container" >&2
            return 1
        fi
        
        # Use MediaWiki importDump maintenance script
        if docker_exec_safe "$WIKI_NAME" "php /app/bluespice/w/maintenance/importDump.php /tmp/restore.xml"; then
            echo "✓ Wiki content restored successfully from XML dump"
        else
            echo "Error: XML dump import failed" >&2
            return 1
        fi
        
        # Clean up
        docker_exec_safe "$WIKI_NAME" "rm -f /tmp/restore.xml"
        
    else
        echo "Error: Unable to determine backup file format (not SQL or XML)" >&2
        return 1
    fi
    
    # Run MediaWiki maintenance updates after restoration
    echo "Running MediaWiki maintenance updates..."
    
    # Update database schema and cache
    if docker_exec_safe "$WIKI_NAME" "php /app/bluespice/w/maintenance/update.php --quick"; then
        echo "✓ Database schema updated"
    else
        echo "Warning: Database schema update encountered issues"
    fi
    
    # Rebuild recent changes
    echo "Rebuilding recent changes..."
    docker_exec_safe "$WIKI_NAME" "php /app/bluespice/w/maintenance/rebuildrecentchanges.php" || true
    
    # Clean up local temporary files
    rm -f "$temp_sql"
    
    echo "✓ Backup restoration completed successfully using MediaWiki maintenance system!"
    return 0
}

# Images import function using images import script
show_completion_info() {
    echo
    echo "================================================"
    log_info "Wiki initialization completed successfully!"
    echo "================================================"
    echo
    echo "Wiki Details:"
    echo "  Name: $WIKI_NAME"
    echo "  Domain: $WIKI_DOMAIN"
    echo "  Language: $WIKI_LANG"
    echo ""
    echo "To view Admin password for user WikiSysop:"
    echo "docker exec bluespice-$WIKI_NAME-wiki-web cat /data/bluespice/initialAdminPassword"
    echo
    
    if [[ "$SETUP_MODE" == "ssl" ]] || [[ "$SSL_ENABLED" == "true" ]]; then
        echo "  URL: https://$WIKI_DOMAIN"
        echo "  SSL: Enabled"
    else
        echo "  URL: http://$WIKI_DOMAIN"
        echo "  SSL: Disabled"
    fi
    
    echo
    echo "✓ Database connectivity: Socket connection configured for optimal performance"
    echo "✓ Unique user authentication: ${WIKI_NAME}_user created with proper permissions"

    echo
    echo "Management commands:"
    echo "  Start:  ./bluespice-deploy-wiki --wiki-name=$WIKI_NAME --domain=$WIKI_DOMAIN"
    echo "  Stop:   docker compose -f /core/wikis/$WIKI_NAME/docker-compose.helper-service.yml -f /core/wikis/$WIKI_NAME/docker-compose.main.yml down"
    echo "  Update: ./bluespice-deploy-wiki --wiki-name=$WIKI_NAME --domain=$WIKI_DOMAIN --run-update"
    echo
    
    return 0
}

# Main execution with improved validation and error handling
main() {
    # Parse command line arguments
    parse_arguments "$@"

    echo "🚀 BlueSpice Wiki Initialization Wizard"
    echo "========================================"
    echo
    
    # Get wiki name with proper validation
    while [[ -z "$WIKI_NAME" ]]; do
        printf "Enter wiki name (alphanumeric, dots, dashes, underscores, no spaces): "
        read -r WIKI_NAME
        
        if ! validate_wiki_name "$WIKI_NAME"; then
            WIKI_NAME=""
            continue
        fi
        
        # Check for existing directory
        if [[ -d "${WIKIS_DIR}/${WIKI_NAME}" ]]; then
            echo
            log_warn "Wiki directory '${WIKIS_DIR}/${WIKI_NAME}' already exists"
            echo "This may contain data from a previous installation."
            echo
            printf "Remove existing directory and continue? [y/N]: "
            read -r confirm
            
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                log_info "Removing existing directory..."
                if rm -rf "${WIKIS_DIR:?}/${WIKI_NAME:?}"; then
                    log_info "Existing directory removed"
                else
                    log_error "Failed to remove existing directory"
                    exit 1
                fi
            else
                log_info "Using existing directory - continuing with current setup..."
                SKIP_DIRECTORY_SETUP=true
            fi
        fi
    done
    
    # Collect configuration if not using existing directory
    if [[ "$SKIP_DIRECTORY_SETUP" != "true" ]]; then
        # Get wiki domain
        while [[ -z "$WIKI_DOMAIN" ]]; do
            printf "Enter wiki domain (e.g., wiki.example.com): "
            read -r WIKI_DOMAIN
            validate_domain "$WIKI_DOMAIN" || WIKI_DOMAIN=""
        done
        
        # Get wiki language
        echo "Available languages: en, de, fr, es, it, pt, nl, pl, ru, ja, zh"
        printf "Enter wiki language code [en]: "
        read -r WIKI_LANG
        WIKI_LANG="${WIKI_LANG:-en}"
        validate_language_code "$WIKI_LANG" || WIKI_LANG="en"
        
        # Get SMTP configuration
        echo
        echo "📧 SMTP Configuration:"
        echo "Configure email settings for wiki notifications"
        echo
        
        # SMTP Host
        while [[ -z "$SMTP_HOST" ]]; do
            printf "Enter SMTP host: "
            read -r SMTP_HOST
            validate_smtp_host "$SMTP_HOST" || SMTP_HOST=""
        done
        
        # SMTP Port
        printf "Enter SMTP port [587]: "
        read -r SMTP_PORT
        SMTP_PORT="${SMTP_PORT:-587}"
        validate_port "$SMTP_PORT" "SMTP port" || SMTP_PORT="587"
        
        # SMTP Username (email)
        while [[ -z "$SMTP_USER" ]]; do
            printf "Enter SMTP username (email address): "
            read -r SMTP_USER
            validate_email "$SMTP_USER" || SMTP_USER=""
        done
        
        # SMTP Password
        while [[ -z "$SMTP_PASS" ]]; do
            printf "Enter SMTP password: "
            read -r SMTP_PASS
            validate_smtp_pass "$SMTP_PASS" || SMTP_PASS=""
        done
        
    else
        log_info "Loading existing configuration..."
        # Load existing configuration from .env file
        local env_file="${WIKIS_DIR}/${WIKI_NAME}/.env"
        if [[ -f "$env_file" ]]; then
            # Source the environment file safely
            # shellcheck disable=SC1090
            source "$env_file" 2>/dev/null || true
            WIKI_DOMAIN="${WIKI_HOST:-}"
            WIKI_LANG="${WIKI_LANG:-en}"
            SMTP_HOST="${SMTP_HOST:-}"
            SMTP_PORT="${SMTP_PORT:-587}"
            SMTP_USER="${SMTP_USER:-}"
            
            log_info "Loaded existing configuration from $env_file"
        else
            log_warn "No .env file found in existing directory"
            log_warn "You will need to configure the wiki manually"
        fi
    fi
    
    # Get setup mode
    echo
    echo "Setup options:"
    echo "1) New wiki with SSL certificate"
    echo "2) New wiki without SSL (HTTP only)"
    echo "3) Restore from backup"
    echo "4) Restore from backup with images"
    
    local choice=""
    while [[ ! "$choice" =~ ^[1-4]$ ]]; do
        printf "Choose option [1/2/3/4]: "
        read -r choice
        if [[ ! "$choice" =~ ^[1-4]$ ]]; then
            echo "❌ Please enter 1, 2, 3, or 4"
        fi
    done
    
    case $choice in
        1)
            SETUP_MODE="ssl"
            SSL_ENABLED=true
            log_info "Selected: New wiki with SSL certificate"
            ;;
        2)
            SETUP_MODE="new"
            SSL_ENABLED=false
            log_info "Selected: New wiki without SSL"
            ;;
        3)
            SETUP_MODE="restore"
            SSL_ENABLED=false
            printf "Enter path to backup file (.sql): "
            read -r BACKUP_FILE
            while [[ -z "$BACKUP_FILE" ]] || ! validate_file_exists "$BACKUP_FILE" "Backup file"; do
                printf "Enter path to backup file (.sql): "
                read -r BACKUP_FILE
            done
            log_info "Selected backup file: $BACKUP_FILE"
            ;;
        4)
            SETUP_MODE="restore_with_images"
            SSL_ENABLED=false
            printf "Enter path to backup file (.sql): "
            read -r BACKUP_FILE
            while [[ -z "$BACKUP_FILE" ]] || ! validate_file_exists "$BACKUP_FILE" "Backup file"; do
                printf "Enter path to backup file (.sql): "
                read -r BACKUP_FILE
            done
            printf "Enter path to images archive (.zip): "
            read -r IMAGES_FILE
            while [[ -z "$IMAGES_FILE" ]] || ! validate_file_exists "$IMAGES_FILE" "Images file"; do
                printf "Enter path to images archive (.zip): "
                read -r IMAGES_FILE
            done
            log_info "Selected backup file: $BACKUP_FILE"
            log_info "Selected images file: $IMAGES_FILE"
            ;;
    esac
    
    # Apply default values and validate configuration
    apply_defaults
    
    # Validate all configuration
    if ! validate_configuration; then
        log_error "Configuration validation failed"
        return 1
    fi
    
    # Show configuration summary and get confirmation
    if ! confirm_configuration; then
        log_info "Setup cancelled by user"
        exit
    fi
    
    echo
    log_info "Starting wiki initialization..."
    
    # Setup process with improved error handling
    if [[ "$SKIP_DIRECTORY_SETUP" != "true" ]]; then
        if ! setup_wiki_directory; then
            log_error "Failed to setup wiki directory"
            return 1
        fi
        
        if ! create_environment_file; then
            log_error "Failed to create environment file"
            return 1
        fi
    else
        log_info "Using existing directory - skipping directory and environment setup"
    fi

    load_environment "${WIKIS_DIR}/${WIKI_NAME}"

    # create the init-settings files
    if ! create-init-settings-config-files "${WIKIS_DIR}/${WIKI_NAME}" "$WIKI_NAME"; then
        log_error "Failed to create init-settings files"
        exit 1
    fi
    
    # Deploy wiki
    if ! deploy_wiki_instance; then
        log_error "Wiki deployment failed"
        exit 1
    fi
    
    # Copy configuration files to the running container
    log_info "Copying configuration files to container..."
    if ! copy_config_files_to_container "$WIKI_NAME" "${WIKIS_DIR}/${WIKI_NAME}"; then
        log_error "Writing configuration files to container failed"
        exit 1
    fi
    
    # Handle backup restoration if selected
    if [[ "$SETUP_MODE" == "restore" ]]; then
        if ! restore_from_backup "$BACKUP_FILE"; then
            log_error "Backup restoration failed"
            local exit_code=1
            echo "Main function returning with exit code: $exit_code"
            exit $exit_code
        fi
    elif [[ "$SETUP_MODE" == "restore_with_images" ]]; then
        if ! restore_from_backup "$BACKUP_FILE"; then
            log_error "Backup restoration failed"
            local exit_code=1
            echo "Main function returning with exit code: $exit_code"
            exit $exit_code
        fi
        if ! import_images "$IMAGES_FILE"; then
            log_error "Images import failed"
            local exit_code=1
            echo "Main function returning with exit code: $exit_code"
            exit $exit_code
        fi
    fi
    
    setup_ssl
    
    # Show completion information
    show_completion_info
    
    # Explicitly exit with success
    local exit_code=0
    echo "Main function returning with exit code: $exit_code"
    exit $exit_code
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
