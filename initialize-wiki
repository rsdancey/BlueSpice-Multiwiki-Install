#!/bin/bash

# BlueSpice Wiki Initialization Script
# Complete setup wizard for new BlueSpice wiki instances

set -euo pipefail

# Script directory and paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WIKIS_DIR="$(dirname "${SCRIPT_DIR}")/wikis"
TEMPLATE_DIR="${SCRIPT_DIR}/wiki-template"

# Source modular libraries
source "${SCRIPT_DIR}/lib/validation.sh"
source "${SCRIPT_DIR}/lib/config.sh"
source "${SCRIPT_DIR}/lib/docker-utils.sh"
source "${SCRIPT_DIR}/lib/oauth-config.sh"

# Default values
WIKI_NAME=""
WIKI_DOMAIN=""
WIKI_LANG="en"
SETUP_MODE=""
SKIP_DIRECTORY_SETUP=false
SSL_ENABLED=false
SMTP_HOST=""
SMTP_PORT="587"
SMTP_USER=""
SMTP_PASS=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1" >&2
}
# Help function
show_help() {
    cat << 'HELP'
BlueSpice Wiki Initialization Wizard
======================================

SYNOPSIS:
    ./initialize-wiki [OPTIONS]

DESCRIPTION:
    Interactive setup wizard for creating new BlueSpice wiki instances.
    Supports fresh installations, backup restoration, and automatic email configuration.

OPTIONS:
    -h, --help          Show this help message and exit

FEATURES:
    • Automated wiki directory setup and environment configuration
    • SSL certificate management with Let's Encrypt integration
    • Intelligent SMTP email configuration with auto-detection
    • Database user creation with secure socket connections
    • Backup restoration with optional image import support
    • Multi-language support (en, de, fr, es, it, pt, nl, pl, ru, ja, zh)
    • Automatic maintenance script installation (sendTestEmail.php)
    • Email configuration validation and prompting

EMAIL CONFIGURATION:
    • Automatic detection of missing SMTP configuration
    • Interactive prompting for incomplete email settings
    • Validation of SMTP hosts, passwords, and settings
    • Support for Office 365, Gmail, and custom SMTP servers
    • Proper MediaWiki email variable configuration ($wgPasswordSender, etc.)
    • Built-in email testing functionality

DATABASE CONNECTIVITY:
    • Unique database users per wiki instance (e.g., wikiname_user)
    • Socket-based connections for optimal performance
    • Automatic password generation and synchronization
    • Secure localhost database access

SSL CERTIFICATES:
    • Automatic Let's Encrypt certificate generation and renewal
    • Certificate expiry monitoring (warns when <30 days remaining)
    • HTTPS redirection and security headers
    • Domain validation and DNS checking

MAINTENANCE SCRIPTS:
    • Automatic installation of sendTestEmail.php for email testing
    • Pre-configured email permissions for users and autoconfirmed users
    • Built-in SMTP configuration validation tools

POST-INSTALLATION:
    After successful setup, your wiki will be accessible at:
    • HTTPS: https://your-domain.com (recommended with SSL)
    • HTTP: http://your-domain.com (fallback without SSL)

    Initial admin credentials are saved in the wiki directory.

MANAGEMENT COMMANDS:
    Start wiki:     ./bluespice-deploy-wiki --wiki-name=NAME --domain=DOMAIN
    Stop wiki:      docker compose -f /core/wikis/NAME/docker-compose.yml down
    Update wiki:    ./bluespice-deploy-wiki --wiki-name=NAME --run-update
    Test email:     docker exec bluespice-NAME-wiki-web php /app/bluespice/w/maintenance/sendTestEmail.php --to=email@domain.com

EXAMPLES:
    ./initialize-wiki                    # Interactive setup mode
    ./initialize-wiki --help            # Show this help message
    
    # Email testing examples:
    docker exec bluespice-Projects-wiki-web php /app/bluespice/w/maintenance/sendTestEmail.php \
        --to="user@example.com" --subject="Test Email"
    
    docker exec bluespice-Projects-wiki-web php /app/bluespice/w/maintenance/sendTestEmail.php \
        --to="user@example.com" --from="wiki@domain.com" --subject="Custom Sender Test"

FILES AND DIRECTORIES:
    /core/wikis/WIKI_NAME/              # Wiki instance directory
    /core/wikis/WIKI_NAME/.env          # Environment configuration
    /core/wikis/WIKI_NAME/pre-init-settings.php   # MediaWiki pre-initialization settings
    /core/wikis/WIKI_NAME/post-init-settings.php  # MediaWiki post-initialization settings
    /core/wikis/WIKI_NAME/initialAdminPassword     # Generated admin password

REQUIREMENTS:
    • Docker and Docker Compose installed and running
    • BlueSpice shared services (database, proxy) running
    • Network connectivity for SSL certificate generation
    • Valid domain name pointing to server (for SSL)

TROUBLESHOOTING:
    • If email configuration is incomplete, the script will automatically prompt
    • Use sendTestEmail.php to verify SMTP configuration
    • Check logs: docker logs bluespice-WIKI_NAME-wiki-web
    • Verify services: docker ps | grep bluespice

For detailed documentation, see README.md or visit the BlueSpice documentation.
HELP
}


# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                echo "Use --help for usage information" >&2
                exit 1
                ;;
        esac
    done
}
# Certificate expiry checking (keeping existing function)
check_certificate_expiry() {
    local domain="$1"
    
    if docker exec bluespice-letsencrypt-service test -f "/etc/nginx/certs/${domain}.crt" 2>/dev/null; then
        local expiry expiry_epoch current_epoch days_until_expiry
        expiry=$(docker exec bluespice-letsencrypt-service openssl x509 -in "/etc/nginx/certs/${domain}.crt" -noout -enddate | cut -d= -f2)
        expiry_epoch=$(date -d "$expiry" +%s)
        current_epoch=$(date +%s)
        days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
        
        if [[ $days_until_expiry -lt 30 ]]; then
            log_warn "SSL certificate expires in $days_until_expiry days"
            return 1
        else
            log_info "SSL certificate valid for $days_until_expiry days"
            return 0
        fi
    else
        log_warn "No SSL certificate found for $domain"
        return 1
    fi
}


# Environment file creation (updated to use config library)
create_environment_file() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    log_info "Creating environment file with configuration..."
    
    # Ensure wiki directory exists
    if [[ ! -d "$wiki_dir" ]]; then
        log_error "Wiki directory does not exist: $wiki_dir"
        return 1
    fi
    
    # Use the new configuration management
    if ! save_configuration "$wiki_dir"; then
        log_error "Failed to create environment configuration"
        return 1
    fi
    
    log_info "Environment file created successfully"
}


# =============================================================================
# Authentication Extension Installation Functions
# =============================================================================

# Function to download and install MediaWiki authentication extensions
install_auth_extensions() {
    local wiki_name=$1
    local container_name="bluespice-${wiki_name}-wiki-web"
    local temp_dir="/tmp/mw_extensions_$$"
    
    echo "Installing authentication extensions for $wiki_name..."
    
    # Create temporary directory for downloads
    mkdir -p "$temp_dir"
    
    # Download PluggableAuth extension
    echo "  Downloading PluggableAuth extension..."
    if ! curl -L --fail --retry 3 -o "$temp_dir/PluggableAuth.tar.gz" \
        "https://extdist.wmflabs.org/dist/extensions/PluggableAuth-REL1_43-8d3e70f.tar.gz"; then
        echo "  Warning: Failed to download PluggableAuth from extension distributor, trying GitHub..."
        if ! curl -L --fail --retry 3 -o "$temp_dir/PluggableAuth.tar.gz" \
            "https://github.com/wikimedia/mediawiki-extensions-PluggableAuth/archive/refs/heads/REL1_43.tar.gz"; then
            echo "  ERROR: Failed to download PluggableAuth extension"
            rm -rf "$temp_dir"
            return 1
        fi
    fi
    
    # Download OpenIDConnect extension
    echo "  Downloading OpenIDConnect extension..."
    if ! curl -L --fail --retry 3 -o "$temp_dir/OpenIDConnect.tar.gz" \
        "https://extdist.wmflabs.org/dist/extensions/OpenIDConnect-REL1_43-52e0b73.tar.gz"; then
        echo "  Warning: Failed to download OpenIDConnect from extension distributor, trying GitHub..."
        if ! curl -L --fail --retry 3 -o "$temp_dir/OpenIDConnect.tar.gz" \
            "https://github.com/wikimedia/mediawiki-extensions-OpenIDConnect/archive/refs/heads/REL1_43.tar.gz"; then
            echo "  ERROR: Failed to download OpenIDConnect extension"
            rm -rf "$temp_dir"
            return 1
        fi
    fi
    
    # Extract extensions
    echo "  Extracting extensions..."
    cd "$temp_dir"
    tar -xzf PluggableAuth.tar.gz
    tar -xzf OpenIDConnect.tar.gz
    
    # Find and rename extracted directories to proper names
    if [ -d "PluggableAuth" ]; then
        echo "  PluggableAuth directory already has correct name"
    elif [ -d "mediawiki-extensions-PluggableAuth-REL1_43" ]; then
        mv "mediawiki-extensions-PluggableAuth-REL1_43" "PluggableAuth"
    else
        # Find and rename the extracted directory
        local pluggable_dir
        pluggable_dir=$(find . -maxdepth 1 -type d -name "*PluggableAuth*" | head -1)
        if [ -n "$pluggable_dir" ]; then
            mv "$pluggable_dir" "PluggableAuth"
        fi
    fi
    
    if [ -d "OpenIDConnect" ]; then
        echo "  OpenIDConnect directory already has correct name"
    elif [ -d "mediawiki-extensions-OpenIDConnect-REL1_43" ]; then
        mv "mediawiki-extensions-OpenIDConnect-REL1_43" "OpenIDConnect"
    else
        # Find and rename the extracted directory
        local openid_dir
        openid_dir=$(find . -maxdepth 1 -type d -name "*OpenIDConnect*" | head -1)
        if [ -n "$openid_dir" ]; then
            mv "$openid_dir" "OpenIDConnect"
        fi
    fi
    
    # Verify directories exist
    if [ ! -d "PluggableAuth" ] || [ ! -d "OpenIDConnect" ]; then
        echo "  ERROR: Failed to extract extensions properly"
        ls -la
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Set proper ownership BEFORE copying to container
    # This ensures files are owned by the same UID/GID that the container uses
    echo "  Preparing extensions for container..."
    # The bluespice user in container has UID/GID 1002
    # We'll set permissions that will work regardless of ownership
    chmod -R 755 PluggableAuth
    chmod -R 755 OpenIDConnect
    
    # Copy extensions to container
    echo "  Copying extensions to container..."
    docker cp "PluggableAuth" "$container_name:/app/bluespice/w/extensions/"
    docker cp "OpenIDConnect" "$container_name:/app/bluespice/w/extensions/"
    
    # Instead of trying to chown (which fails), just ensure permissions are correct
    # The files will be readable/executable by all users including bluespice
    echo "  Setting permissions..."
    docker exec "$container_name" chmod -R 755 /app/bluespice/w/extensions/PluggableAuth 2>/dev/null || true
    docker exec "$container_name" chmod -R 755 /app/bluespice/w/extensions/OpenIDConnect 2>/dev/null || true
    
    # Verify installation
    echo "  Verifying installation..."
    if docker exec "$container_name" test -f /app/bluespice/w/extensions/PluggableAuth/extension.json && \
       docker exec "$container_name" test -f /app/bluespice/w/extensions/OpenIDConnect/extension.json; then
        echo "  ✓ Authentication extensions installed successfully"
        
        # Add extension configuration to post-init-settings.php AFTER successful installation
        echo "  Adding extension configuration to post-init-settings.php..."
        local post_init_file="/data/bluespice/post-init-settings.php"
        
        # Check if configuration already exists
        if docker exec "$container_name" grep -q "wfLoadExtension.*PluggableAuth" "$post_init_file" 2>/dev/null; then
            echo "  Extension configuration already exists in post-init-settings.php"
        else
            # Add the extension configuration
            docker exec "$container_name" bash -c "cat >> '$post_init_file' << 'AUTH_CONFIG_EOF'

# Load web-only auth integrations (skip for CLI/maintenance)
if ( !isset(\\\$wgCommandLineMode) || !\\\$wgCommandLineMode ) {
    wfLoadExtension( 'PluggableAuth' );
    wfLoadExtension( 'OpenIDConnect' );
}
AUTH_CONFIG_EOF"
            echo "  ✓ Extension configuration added to post-init-settings.php"
        fi
        
        # Configure OAuth settings after successful extension installation
        local wiki_domain=$(grep "^WIKI_HOST=" /core/wikis/${wiki_name}/.env 2>/dev/null | cut -d'=' -f2 | tr -d '"')
        
        if [ -n "$wiki_domain" ]; then
            echo ""
            echo "Extensions installed successfully. Now configuring OAuth..."
            # Call configure_oauth_settings with correct parameters
            configure_oauth_settings "$wiki_name" "$wiki_domain" "$post_init_file"
        else
            echo "Warning: Could not determine wiki domain for OAuth configuration"
        fi
        
        # Clean up temporary files
        cd /
        rm -rf "$temp_dir"
        return 0
    else
        echo "  ERROR: Extension installation verification failed"
        cd /
        rm -rf "$temp_dir"
        return 1
    fi
}

# Function to check if authentication extensions need to be installed
check_auth_extensions_needed() {
    local wiki_name=$1
    local container_name="bluespice-${wiki_name}-wiki-web"
    
    # Check if container is running
    if ! docker ps | grep -q "$container_name"; then
        echo "  Container $container_name is not running"
        return 2
    fi
    
    # Check if extensions already exist
    if docker exec "$container_name" test -d /app/bluespice/w/extensions/PluggableAuth 2>/dev/null && \
       docker exec "$container_name" test -d /app/bluespice/w/extensions/OpenIDConnect 2>/dev/null; then
        echo "  Authentication extensions already installed"
        return 1
    fi
    
    # Extensions need to be installed
    return 0
}

# OAuth Configuration Function
# =============================================================================

# Function to configure Google OAuth settings
configure_oauth_settings() {
    local wiki_name=$1
    local wiki_domain=$2
    local post_init_file=$3
    
    echo ""
    echo "==================================================================="
    echo "Google OAuth Configuration (Optional)"
    echo "==================================================================="
    echo ""
    echo "To enable 'Login with Google' functionality, you need to:"
    echo "1. Create a Google Cloud project at https://console.cloud.google.com"
    echo "2. Enable Google+ API"
    echo "3. Create OAuth 2.0 credentials"
    echo "4. Add this as authorized redirect URI:"
    echo "   https://${wiki_domain}/index.php/Special:PluggableAuthLogin"
    echo ""
    
    printf "Do you want to configure Google OAuth now? [y/N]: "
    read -r configure_oauth
    
    if [[ "${configure_oauth,,}" == "y" ]]; then
        # Get OAuth credentials
        printf "Enter Google OAuth Client ID (or press Enter to skip): "
        read -r oauth_client_id
        
        if [[ -n "$oauth_client_id" ]]; then
            printf "Enter Google OAuth Client Secret: "
            read -r oauth_client_secret
            
            while [[ -z "$oauth_client_secret" ]]; do
                echo "Client Secret is required when Client ID is provided"
                printf "Enter Google OAuth Client Secret: "
                read -r oauth_client_secret
            done
            
            # Ask about account creation settings
            printf "Allow automatic account creation for Google users? [y/N]: "
            read -r allow_autocreate
            
            local create_if_not_exist="false"
            local email_matching_only="true"
            
            if [[ "${allow_autocreate,,}" == "y" ]]; then
                create_if_not_exist="true"
                email_matching_only="false"
            fi
            
            # Write OAuth configuration to post-init-settings.php
            cat >> "$post_init_file" <<OAUTH_CONFIG_EOF

# ============================================
# Google OAuth Configuration
# ============================================

# Whitelist some pages for public access
\$wgWhitelistRead = [
    'Privacy Policy',
    'Special:Login',
    'Special:CreateAccount',
    'Special:CreateAccount/return'
];

# Google OAuth configuration
\$wgPluggableAuth_Config["Google"] = [
    "plugin" => "OpenIDConnect",
    "data" => [
        "providerURL" => "https://accounts.google.com/.well-known/openid-configuration",
        "clientID" => "${oauth_client_id}",
        "clientSecret" => "${oauth_client_secret}",
        "scope" => ["openid", "email", "profile"],
        "email_key" => "email",
        "use_email_mapping" => true
    ],
    "buttonLabelMessage" => "Login with Google"
];

# Enable local login alongside PluggableAuth
\$wgPluggableAuth_EnableLocalLogin = true;
\$wgPluggableAuth_EnableAutoLogin = false;

# OAuth email matching and account creation settings
\$wgPluggableAuth_EmailMatchingOnly = ${email_matching_only};
\$wgPluggableAuth_CreateIfDoesNotExist = ${create_if_not_exist};

# Explicitly prevent automatic user creation if not enabled
\$wgGroupPermissions["*"]["autocreateaccount"] = ${create_if_not_exist};

# Additional OpenIDConnect settings
\$wgOpenIDConnect_UseEmailNameAsUserName = false;
\$wgOpenIDConnect_MigrateUsersByEmail = true;
\$wgOpenIDConnect_UseRealNameAsUserName = false;
OAUTH_CONFIG_EOF
            
            echo ""
            echo "OAuth configuration added successfully!"
            echo "  Client ID: ${oauth_client_id:0:20}..."
            echo "  Auto-create accounts: ${create_if_not_exist}"
            echo ""
            echo "IMPORTANT: Make sure to add this redirect URI in Google Cloud Console:"
            echo "  https://${wiki_domain}/index.php/Special:PluggableAuthLogin"
            
            # Store OAuth settings in .env file for reference
            local env_file="${WIKIS_DIR}/${wiki_name}/.env"
            {
                echo ""
                echo "# Google OAuth Settings"
                echo "OAUTH_CLIENT_ID=${oauth_client_id}"
                echo "OAUTH_CLIENT_SECRET=${oauth_client_secret}"
                echo "OAUTH_AUTOCREATE=${create_if_not_exist}"
            } >> "$env_file"
            
        else
            echo "OAuth configuration skipped. You can add it later by editing:"
            echo "  /data/bluespice/post-init-settings.php"
            
            # Add placeholder configuration
            cat >> "$post_init_file" <<'OAUTH_PLACEHOLDER_EOF'

# ============================================
# Google OAuth Configuration (Not Configured)
# ============================================
# To enable Google OAuth login:
# 1. Get credentials from https://console.cloud.google.com
# 2. Uncomment and update the configuration below
# 3. Add redirect URI: https://YOUR-DOMAIN/index.php/Special:PluggableAuthLogin

/*
$wgWhitelistRead = [
    'Privacy Policy',
    'Special:Login', 
    'Special:CreateAccount',
    'Special:CreateAccount/return'
];

$wgPluggableAuth_Config["Google"] = [
    "plugin" => "OpenIDConnect",
    "data" => [
        "providerURL" => "https://accounts.google.com/.well-known/openid-configuration",
        "clientID" => "YOUR_GOOGLE_CLIENT_ID",
        "clientSecret" => "YOUR_GOOGLE_CLIENT_SECRET",
        "scope" => ["openid", "email", "profile"],
        "email_key" => "email",
        "use_email_mapping" => true
    ],
    "buttonLabelMessage" => "Login with Google"
];

$wgPluggableAuth_EnableLocalLogin = true;
$wgPluggableAuth_EnableAutoLogin = false;
$wgPluggableAuth_EmailMatchingOnly = true;
$wgPluggableAuth_CreateIfDoesNotExist = false;
$wgGroupPermissions["*"]["autocreateaccount"] = false;
$wgOpenIDConnect_UseEmailNameAsUserName = false;
$wgOpenIDConnect_MigrateUsersByEmail = true;
$wgOpenIDConnect_UseRealNameAsUserName = false;
*/
OAUTH_PLACEHOLDER_EOF
        fi
    else
        echo "OAuth configuration skipped."
        
        # Add placeholder configuration
        cat >> "$post_init_file" <<'OAUTH_PLACEHOLDER_EOF'

# ============================================
# Google OAuth Configuration (Not Configured)
# ============================================
# To enable Google OAuth login:
# 1. Get credentials from https://console.cloud.google.com
# 2. Uncomment and update the configuration below
# 3. Add redirect URI: https://YOUR-DOMAIN/index.php/Special:PluggableAuthLogin

/*
$wgWhitelistRead = [
    'Privacy Policy',
    'Special:Login',
    'Special:CreateAccount',
    'Special:CreateAccount/return'
];

$wgPluggableAuth_Config["Google"] = [
    "plugin" => "OpenIDConnect",
    "data" => [
        "providerURL" => "https://accounts.google.com/.well-known/openid-configuration",
        "clientID" => "YOUR_GOOGLE_CLIENT_ID",
        "clientSecret" => "YOUR_GOOGLE_CLIENT_SECRET",
        "scope" => ["openid", "email", "profile"],
        "email_key" => "email",
        "use_email_mapping" => true
    ],
    "buttonLabelMessage" => "Login with Google"
];

$wgPluggableAuth_EnableLocalLogin = true;
$wgPluggableAuth_EnableAutoLogin = false;
$wgPluggableAuth_EmailMatchingOnly = true;
$wgPluggableAuth_CreateIfDoesNotExist = false;
$wgGroupPermissions["*"]["autocreateaccount"] = false;
$wgOpenIDConnect_UseEmailNameAsUserName = false;
$wgOpenIDConnect_MigrateUsersByEmail = true;
$wgOpenIDConnect_UseRealNameAsUserName = false;
*/
OAUTH_PLACEHOLDER_EOF
    fi
}
check_and_prompt_email_config() {
    local env_file="$1"
    local smtp_host smtp_user smtp_pass
    
    if [[ -f "$env_file" ]]; then
        smtp_host=$(grep "^SMTP_HOST=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_user=$(grep "^SMTP_USER=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_pass=$(grep "^SMTP_PASS=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        
        # If any email config is missing, prompt for it
        if [[ -z "$smtp_host" || -z "$smtp_user" || -z "$smtp_pass" ]]; then
            echo "Email configuration incomplete in .env file."
            echo "Missing SMTP configuration detected. Please provide email settings:"
            echo
            configure_smtp
            
            # Update the .env file with new SMTP settings
            sed -i "s/^SMTP_HOST=.*/SMTP_HOST=${SMTP_HOST}/" "$env_file"
            sed -i "s/^SMTP_PORT=.*/SMTP_PORT=${SMTP_PORT}/" "$env_file"
            sed -i "s/^SMTP_USER=.*/SMTP_USER=${SMTP_USER}/" "$env_file"
            sed -i "s/^SMTP_PASS=.*/SMTP_PASS=${SMTP_PASS}/" "$env_file"
        fi
    fi
}


# Email configuration file creation
create_email_config_files() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    local env_file="${wiki_dir}/.env"
    local pre_init_file="${wiki_dir}/pre-init-settings.php"
    local post_init_file="${wiki_dir}/post-init-settings.php"
    
    echo "Creating email configuration files..."
    
    # Check and prompt for missing email configuration
    check_and_prompt_email_config "$env_file"
    
    # Read SMTP settings from .env file
    local smtp_host smtp_port smtp_user smtp_pass smtp_idhost
    if [[ -f "$env_file" ]]; then
        smtp_host=$(grep "^SMTP_HOST=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_port=$(grep "^SMTP_PORT=" "$env_file" | cut -d= -f2 2>/dev/null || echo "587")
        smtp_user=$(grep "^SMTP_USER=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_pass=$(grep "^SMTP_PASS=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
        smtp_idhost=$(grep "^WIKI_HOST=" "$env_file" | cut -d= -f2 2>/dev/null || echo "")
    else
        echo "Warning: .env file not found for email configuration"
        return 1
    fi
    
    # Create pre-init-settings.php with email permissions
    cat > "$pre_init_file" << 'PREINIT_EOF'
<?php

# Enable email permissions for users
\$wgGroupPermissions['user']['sendemail'] = true;
\$wgGroupPermissions['autoconfirmed']['sendemail'] = true;
PREINIT_EOF
    
    echo "Created pre-init-settings.php with email permissions"
    
    # Create post-init-settings.php with email configuration (only if SMTP is configured)
    if [[ -n "$smtp_host" && -n "$smtp_user" && -n "$smtp_pass" ]]; then
        cat > "$post_init_file" << POSTINIT_EOF
<?php

# Override the default with a bundle of filetypes:
\$wgFileExtensions = array('png', 'gif', 'jpg', 'jpeg', 'ppt', 'pdf', 
'psd', 'mp3', 'xls', 'xlsx', 'doc','docx', 'mp4', 'mov', 'ico' );

\$wgCookieExpiration = 86400;
\$wgExtendedLoginCookieExpiration = null;

# Email configuration
\$wgPasswordSender = '$smtp_user';
\$wgEmergencyContact = '$smtp_user';
\$wgNoReplyAddress = '$smtp_user';

# SMTP configuration
\$wgSMTP = [
    'host'     => '$smtp_host',
    'IDHost'   => '$smtp_idhost',
    'port'     => $smtp_port,
    'auth'     => true,
    'username' => '$smtp_user',
    'password' => '$smtp_pass'
];
POSTINIT_EOF
        



        # Append guarded auth extensions so maintenance/CLI can run in task container
        echo "Created post-init-settings.php with SMTP configuration"

        echo "  SMTP Host: $smtp_host"
        echo "  SMTP User: $smtp_user"
        echo "  Email sender: $smtp_user"
    else
        # Create minimal post-init file if no SMTP configured
        cat > "$post_init_file" << 'POSTINIT_MINIMAL_EOF'
<?php

# Override the default with a bundle of filetypes:
\$wgFileExtensions = array('png', 'gif', 'jpg', 'jpeg', 'ppt', 'pdf', 
'psd', 'mp3', 'xls', 'xlsx', 'doc','docx', 'mp4', 'mov', 'ico' );

\$wgCookieExpiration = 86400;
\$wgExtendedLoginCookieExpiration = null;

# Post-initialization settings
# Add custom configurations here
POSTINIT_MINIMAL_EOF
        

        # Append guarded auth extensions so maintenance/CLI can run in task container
        echo "Created minimal post-init-settings.php (no SMTP configured)"
    fi
}

# Wiki directory setup
setup_wiki_directory() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    echo "Setting up wiki directory: $wiki_dir"
    mkdir -p "$wiki_dir"
    
    if [[ "$SETUP_MODE" == "restore" ]]; then
        echo "Preparing directory for backup restoration..."
        # Copy essential files only
        cp "${TEMPLATE_DIR}/docker-compose."* "$wiki_dir/"
    else
        echo "Copying template files..."
        cp -r "${TEMPLATE_DIR}/"* "$wiki_dir/"
    fi
    
    echo "Wiki directory prepared"
}

# Wiki deployment with improved OAuth extension handling
deploy_wiki() {
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    log_info "Deploying wiki instance..."
    
    cd "$wiki_dir"
    
    # Deploy with fresh installation
    if ! "${SCRIPT_DIR}/bluespice-deploy-wiki" \
        --wiki-name="$WIKI_NAME" \
        --fresh-install; then
        log_error "Wiki deployment failed"
        exit 1
    fi
    
    log_info "Wiki deployed successfully"

    # Wait for container to be fully ready before installing extensions
    log_info "Waiting for wiki container to be ready..."
    if ! wait_for_container_ready "$WIKI_NAME" 60; then
        log_error "Container failed to become ready - OAuth extensions cannot be installed"
        log_warn "You may need to install OAuth extensions manually later"
        return 0
    fi

    # Install and configure OAuth extensions using the new modular system
    log_info "Setting up OAuth extensions..."
    if ! setup_oauth_extensions "$WIKI_NAME" "$WIKI_DOMAIN"; then
        log_error "CRITICAL: OAuth extension setup failed"
        log_warn "Wiki is functional but OAuth authentication will not work"
        log_warn "Manual intervention may be required"
        return 1
    fi
    
    log_info "OAuth extension setup completed successfully"
}

# SSL setup
setup_ssl() {
    if [[ "$SETUP_MODE" == "ssl" ]] || [[ "$SSL_ENABLED" == "true" ]]; then
        echo "SSL certificate will be automatically generated by Let's Encrypt"
        echo "This may take a few minutes..."
    fi
}

# Backup restoration function using proper MediaWiki maintenance approach
restore_from_backup() {
    local backup_file="$1"
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    echo "Starting backup restoration using MediaWiki maintenance system..."
    
    # Check if backup file exists
    if [[ ! -f "$backup_file" ]]; then
        echo "Error: Backup file not found: $backup_file" >&2
        return 1
    fi
    
    # Determine file type and prepare for restoration
    local file_ext="${backup_file##*.}"
    local temp_sql="/tmp/restore_backup.sql"
    
    echo "Preparing backup file for restoration..."
    
    # Handle different file formats
    case "$file_ext" in
        "gz")
            echo "Decompressing gzip file..."
            if ! gunzip -c "$backup_file" > "$temp_sql"; then
                echo "Error: Failed to decompress backup file" >&2
                return 1
            fi
            ;;
        "sql")
            echo "Using SQL file directly..."
            cp "$backup_file" "$temp_sql"
            ;;
        *)
            echo "Error: Unsupported backup file format. Supported: .sql, .sql.gz" >&2
            return 1
            ;;
    esac
    
    # Check if it is a SQL dump (not XML)
    if head -5 "$temp_sql" | grep -q "MySQL dump\|MariaDB dump\|-- Dump completed"; then
        echo "Detected SQL database dump - using database restoration method"
        
        # Get database credentials
        local db_user
        db_user=$(grep DB_USER "$wiki_dir/.env" | cut -d= -f2)
        
        echo "Restoring database from SQL dump using smart importer..."
        
        # Use smart database importer with prefix detection
        local smart_importer="$SCRIPT_DIR/smart_db_import.sh"
        
        
        if [[ ! -f "$smart_importer" ]]; then
            echo "Error: Smart database importer not found at: $smart_importer" >&2
            return 1
        fi
        
        # Set up environment for smart importer
        export WIKI_DIR="$wiki_dir"
        export SQL_FILE="$temp_sql"
        
        # Call the smart importer script
        if "$smart_importer" "$temp_sql"; then
            echo "✓ Database restored successfully using smart importer"
        else
            echo "Error: Smart database import failed" >&2
            return 1
        fi
        
    elif head -5 "$temp_sql" | grep -q "<mediawiki\|<siteinfo"; then
        echo "Detected MediaWiki XML dump - using importDump.php"
        
        # Copy XML file to wiki container
        docker cp "$temp_sql" "bluespice-${WIKI_NAME}-wiki-web:/tmp/restore.xml"
        
        # Use MediaWiki importDump maintenance script
        if docker exec "bluespice-${WIKI_NAME}-wiki-web" php /app/bluespice/w/maintenance/importDump.php /tmp/restore.xml; then
            echo "✓ Wiki content restored successfully from XML dump"
        else
            echo "Error: XML dump import failed" >&2
            return 1
        fi
        
        # Clean up
        docker exec "bluespice-${WIKI_NAME}-wiki-web" rm -f /tmp/restore.xml
        
    else
        echo "Error: Unable to determine backup file format (not SQL or XML)" >&2
        return 1
    fi
    
    # Run MediaWiki maintenance updates after restoration
    echo "Running MediaWiki maintenance updates..."
    
    # Update database schema and cache
    if docker exec "bluespice-${WIKI_NAME}-wiki-web" php /app/bluespice/w/maintenance/update.php --quick; then
        echo "✓ Database schema updated"
    else
        echo "Warning: Database schema update encountered issues"
    fi
    
    # Rebuild recent changes
    echo "Rebuilding recent changes..."
    docker exec "bluespice-${WIKI_NAME}-wiki-web" php /app/bluespice/w/maintenance/rebuildrecentchanges.php || true
    
    # Clean up local temporary files
    rm -f "$temp_sql"
    
    echo "✓ Backup restoration completed successfully using MediaWiki maintenance system!"
    return 0
}




# Images import function using images import script
import_images() {
    local images_file="$1"
    local wiki_dir="${WIKIS_DIR}/${WIKI_NAME}"
    
    echo "Starting images import..."
    
    if [[ ! -f "$images_file" ]]; then
        echo "Error: Images file not found: $images_file" >&2
        return 1
    fi
    
    local script_dir="/core/core_install"
    local images_importer="$script_dir/import-images.sh"
    
    if [[ ! -f "$images_importer" ]]; then
        echo "Error: Images import script not found at: $images_importer" >&2
        return 1
    fi
    
    echo "Using images import script to import images..."
    
    if "$images_importer" --wiki-name="$WIKI_NAME" --images-archive="$images_file"; then
        echo "✓ Images imported successfully"
        return 0
    else
        echo "Error: Images import failed" >&2
        return 1
    fi
}

# Display completion information
show_completion_info() {
    echo
    echo "================================================"
    echo "Wiki initialization completed successfully!"
    echo "================================================"
    echo
    echo "Wiki Details:"
    echo "  Name: $WIKI_NAME"
    echo "  Domain: $WIKI_DOMAIN"
    echo "  Language: $WIKI_LANG"
    echo ""
    echo "To view Admin password for user WikiSysop:"
    echo "docker exec bluespice-$WIKI_NAME-wiki-web cat /data/bluespice/initialAdminPassword"
    echo
    
    if [[ "$SETUP_MODE" == "ssl" ]] || [[ "$SSL_ENABLED" == "true" ]]; then
        echo "  URL: https://$WIKI_DOMAIN"
        echo "  SSL: Enabled"
    else
        echo "  URL: http://$WIKI_DOMAIN"
        echo "  SSL: Disabled"
    fi
    
    echo
    echo "✓ Database connectivity: Socket connection configured for optimal performance"
    echo "✓ Unique user authentication: ${WIKI_NAME}_user created with proper permissions"

    echo
    echo "Management commands:"
    echo "  Start:  ./bluespice-deploy-wiki --wiki-name=$WIKI_NAME --domain=$WIKI_DOMAIN"
    echo "  Stop:   docker compose -f /core/wikis/$WIKI_NAME/docker-compose.helper-service.yml -f /core/wikis/$WIKI_NAME/docker-compose.main.yml down"
    echo "  Update: ./bluespice-deploy-wiki --wiki-name=$WIKI_NAME --domain=$WIKI_DOMAIN --run-update"
    echo
}

# Main execution with improved validation and error handling
main() {
    # Parse command line arguments
    parse_arguments "$@"

    echo "🚀 BlueSpice Wiki Initialization Wizard"
    echo "========================================"
    echo
    
    # Get wiki name with proper validation
    while [[ -z "$WIKI_NAME" ]]; do
        printf "Enter wiki name (alphanumeric, dots, dashes, underscores, no spaces): "
        read -r WIKI_NAME
        
        if ! validate_wiki_name "$WIKI_NAME"; then
            WIKI_NAME=""
            continue
        fi
        
        # Check for existing directory
        if [[ -d "${WIKIS_DIR}/${WIKI_NAME}" ]]; then
            echo
            log_warn "Wiki directory '${WIKIS_DIR}/${WIKI_NAME}' already exists"
            echo "This may contain data from a previous installation."
            echo
            printf "Remove existing directory and continue? [y/N]: "
            read -r confirm
            
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                log_info "Removing existing directory..."
                if rm -rf "${WIKIS_DIR:?}/${WIKI_NAME:?}"; then
                    log_info "Existing directory removed"
                else
                    log_error "Failed to remove existing directory"
                    exit 1
                fi
            else
                log_info "Using existing directory - continuing with current setup..."
                SKIP_DIRECTORY_SETUP=true
            fi
        fi
    done
    
    # Collect configuration if not using existing directory
    if [[ "$SKIP_DIRECTORY_SETUP" != "true" ]]; then
        # Get wiki domain
        while [[ -z "$WIKI_DOMAIN" ]]; do
            printf "Enter wiki domain (e.g., wiki.example.com): "
            read -r WIKI_DOMAIN
            validate_domain "$WIKI_DOMAIN" || WIKI_DOMAIN=""
        done
        
        # Get wiki language
        echo "Available languages: en, de, fr, es, it, pt, nl, pl, ru, ja, zh"
        printf "Enter wiki language code [en]: "
        read -r WIKI_LANG
        WIKI_LANG="${WIKI_LANG:-en}"
        validate_language_code "$WIKI_LANG" || WIKI_LANG="en"
        
        # Get SMTP configuration
        echo
        echo "📧 SMTP Configuration:"
        echo "Configure email settings for wiki notifications"
        echo
        
        # SMTP Host
        while [[ -z "$SMTP_HOST" ]]; do
            printf "Enter SMTP host: "
            read -r SMTP_HOST
            validate_smtp_host "$SMTP_HOST" || SMTP_HOST=""
        done
        
        # SMTP Port
        printf "Enter SMTP port [587]: "
        read -r SMTP_PORT
        SMTP_PORT="${SMTP_PORT:-587}"
        validate_port "$SMTP_PORT" "SMTP port" || SMTP_PORT="587"
        
        # SMTP Username (email)
        while [[ -z "$SMTP_USER" ]]; do
            printf "Enter SMTP username (email address): "
            read -r SMTP_USER
            validate_email "$SMTP_USER" || SMTP_USER=""
        done
        
        # SMTP Password
        while [[ -z "$SMTP_PASS" ]]; do
            printf "Enter SMTP password: "
            read -r SMTP_PASS
            validate_smtp_pass "$SMTP_PASS" || SMTP_PASS=""
        done
        
    else
        log_info "Loading existing configuration..."
        # Load existing configuration from .env file
        local env_file="${WIKIS_DIR}/${WIKI_NAME}/.env"
        if [[ -f "$env_file" ]]; then
            # Source the environment file safely
            source "$env_file" 2>/dev/null || true
            WIKI_DOMAIN="${WIKI_HOST:-}"
            WIKI_LANG="${WIKI_LANG:-en}"
            SMTP_HOST="${SMTP_HOST:-}"
            SMTP_PORT="${SMTP_PORT:-587}"
            SMTP_USER="${SMTP_USER:-}"
            
            log_info "Loaded existing configuration from $env_file"
        else
            log_warn "No .env file found in existing directory"
            log_warn "You will need to configure the wiki manually"
        fi
    fi
    
    # Get setup mode
    echo
    echo "Setup options:"
    echo "1) New wiki with SSL certificate"
    echo "2) New wiki without SSL (HTTP only)"
    echo "3) Restore from backup"
    echo "4) Restore from backup with images"
    
    local choice=""
    while [[ ! "$choice" =~ ^[1-4]$ ]]; do
        printf "Choose option [1/2/3/4]: "
        read -r choice
        if [[ ! "$choice" =~ ^[1-4]$ ]]; then
            echo "❌ Please enter 1, 2, 3, or 4"
        fi
    done
    
    case $choice in
        1)
            SETUP_MODE="ssl"
            SSL_ENABLED=true
            log_info "Selected: New wiki with SSL certificate"
            ;;
        2)
            SETUP_MODE="new"
            SSL_ENABLED=false
            log_info "Selected: New wiki without SSL"
            ;;
        3)
            SETUP_MODE="restore"
            SSL_ENABLED=false
            printf "Enter path to backup file (.sql): "
            read -r BACKUP_FILE
            while [[ -z "$BACKUP_FILE" ]] || ! validate_file_exists "$BACKUP_FILE" "Backup file"; do
                printf "Enter path to backup file (.sql): "
                read -r BACKUP_FILE
            done
            log_info "Selected backup file: $BACKUP_FILE"
            ;;
        4)
            SETUP_MODE="restore_with_images"
            SSL_ENABLED=false
            printf "Enter path to backup file (.sql): "
            read -r BACKUP_FILE
            while [[ -z "$BACKUP_FILE" ]] || ! validate_file_exists "$BACKUP_FILE" "Backup file"; do
                printf "Enter path to backup file (.sql): "
                read -r BACKUP_FILE
            done
            printf "Enter path to images archive (.zip): "
            read -r IMAGES_FILE
            while [[ -z "$IMAGES_FILE" ]] || ! validate_file_exists "$IMAGES_FILE" "Images file"; do
                printf "Enter path to images archive (.zip): "
                read -r IMAGES_FILE
            done
            log_info "Selected backup file: $BACKUP_FILE"
            log_info "Selected images file: $IMAGES_FILE"
            ;;
    esac
    
    # Apply default values and validate configuration
    apply_defaults
    
    # Validate all configuration
    if ! validate_configuration; then
        log_error "Configuration validation failed"
        exit 1
    fi
    
    # Show configuration summary and get confirmation
    if ! confirm_configuration; then
        log_info "Setup cancelled by user"
        exit 0
    fi
    
    echo
    log_info "Starting wiki initialization..."
    
    # Setup process with improved error handling
    if [[ "$SKIP_DIRECTORY_SETUP" != "true" ]]; then
        if ! setup_wiki_directory; then
            log_error "Failed to setup wiki directory"
            exit 1
        fi
        
        if ! create_environment_file; then
            log_error "Failed to create environment file"
            exit 1
        fi
        
        if ! create_email_config_files; then
            log_error "Failed to create email configuration files"
            exit 1
        fi
    else
        log_info "Using existing directory - skipping directory and environment setup"
    fi
    
    # Deploy wiki with OAuth extensions
    if ! deploy_wiki; then
        log_error "Wiki deployment failed"
        exit 1
    fi
    
    # Handle backup restoration if selected
    if [[ "$SETUP_MODE" == "restore" ]]; then
        if ! restore_from_backup "$BACKUP_FILE"; then
            log_error "Backup restoration failed"
            exit 1
        fi
    elif [[ "$SETUP_MODE" == "restore_with_images" ]]; then
        if ! restore_from_backup "$BACKUP_FILE"; then
            log_error "Backup restoration failed"
            exit 1
        fi
        if ! import_images "$IMAGES_FILE"; then
            log_error "Images import failed"
            exit 1
        fi
    fi
    
    setup_ssl
    
    # Show completion information
    show_completion_info
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
