#!/bin/bash

# BlueSpice Shared Services Management
# Manages shared services like database, cache, search, etc.

set -euo pipefail

# Script directory and configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GLOBAL_ENV="${SCRIPT_DIR}/.global.env"
SHARED_ENV="${SCRIPT_DIR}/shared/.shared.env"

# Default values
EDITION="free"
VERSION="5.1"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Source environment files
source_environment() {
    # Source global environment
    if [[ -f "$GLOBAL_ENV" ]]; then
        source "$GLOBAL_ENV"
    fi
    
    # Source shared environment
    if [[ -f "$SHARED_ENV" ]]; then
        source "$SHARED_ENV"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Warning: Shared environment file not found: $SHARED_ENV${NC}"
        echo -e "${YELLOW}üí° Run './shared/generate-passwords' first${NC}"
    fi
}

# Progress indicator
show_progress() {
    local message="$1"
    local duration="${2:-3}"
    
    echo -ne "${BLUE}üîÑ $message"
    for ((i=0; i<duration; i++)); do
        sleep 1
        echo -ne "."
    done
    echo -e " ${GREEN}Done${NC}"
}

# Display service status with colors and icons
# Display service status with Docker Compose style formatting
display_service_status() {
    local service_name="$1"
    local status="$2"
    local uptime=""
    
    # Get container uptime if it exists
    if docker inspect "$service_name" >/dev/null 2>&1; then
        uptime=$(docker inspect --format='{{.State.StartedAt}}' "$service_name" 2>/dev/null | xargs -I {} date -d {} +%s 2>/dev/null || echo "")
        if [[ -n "$uptime" ]]; then
            local current_time=$(date +%s)
            local elapsed=$((current_time - uptime))
            if [[ $elapsed -lt 60 ]]; then
                uptime="${elapsed}s"
            elif [[ $elapsed -lt 3600 ]]; then
                uptime="$((elapsed / 60))m"
            else
                uptime="$((elapsed / 3600))h"
            fi
        else
            uptime="0s"
        fi
    fi
    
    # Format exactly like Docker Compose with precise column widths
    case "$status" in
        "starting")
            printf " %b %-45s %b%*s%s\n" \
                "${YELLOW}‚†ø${NC}" "Container $service_name" "${YELLOW}Starting${NC}" 70 "" "$uptime"
            ;;
        "healthy")
            printf " %b %-45s %b%*s%s\n" \
                "${GREEN}‚úî${NC}" "Container $service_name" "${GREEN}Healthy${NC}" 71 "" "$uptime"
            ;;
        "unhealthy")
            printf " %b %-45s %b%*s%s\n" \
                "${RED}‚úó${NC}" "Container $service_name" "${RED}Unhealthy${NC}" 69 "" "$uptime"
            ;;
        "running")
            printf " %b %-45s %b%*s%s\n" \
                "${GREEN}‚úî${NC}" "Container $service_name" "${GREEN}Running${NC}" 71 "" "$uptime"
            ;;
        "stopped")
            printf " %b %-45s %b%*s%s\n" \
                "${RED}‚èπÔ∏è${NC}" "Container $service_name" "${RED}Stopped${NC}" 71 "" "$uptime"
            ;;
        "not_found")
            printf " %b %-45s %b%*s%s\n" \
                "${PURPLE}‚ùì${NC}" "Container $service_name" "${PURPLE}Not Found${NC}" 68 "" ""
            ;;
        *)
            printf " %b %-45s %b%*s%s\n" \
                "${PURPLE}‚ùî${NC}" "Container $service_name" "${PURPLE}$status${NC}" $((77 - ${#status})) "" "$uptime"
            ;;
    esac
}

# Get container status
get_container_status() {
    local container_name="$1"
    local status
    local health
    
    # Suppress all docker command output
    status=$(docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null || echo "")
    health=$(docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "")
    
    if [[ -z "$status" ]]; then
        echo "not_found"
    elif [[ "$status" == "running" ]]; then
        if [[ "$health" == "healthy" ]]; then
            echo "healthy"
        elif [[ "$health" == "starting" ]]; then
            echo "starting"
        elif [[ "$health" == "unhealthy" ]]; then
            echo "unhealthy"
        else
            echo "running"
        fi
    else
        echo "$status"
    fi
}

# Monitor services with clean status updates like Docker Compose
monitor_services_startup() {
    local services=("$@")
    local max_attempts=120
    local attempt=0
    
    echo
    echo -e "${CYAN}üìä Service Status Monitor${NC}"
    echo -e "${CYAN}========================${NC}"
    
    while [[ $attempt -lt $max_attempts ]]; do
        local all_healthy=true
        local healthy_count=0
        local total_count=${#services[@]}
        
        # Clear previous output if this isn't the first attempt
        if [[ $attempt -gt 0 ]]; then
            # Move cursor up and clear lines for: header + services + progress line
            for ((i=0; i<=${#services[@]}+2; i++)); do
                printf "\033[A\033[K"
            done
        fi
        
        # Show header
        printf "\n"
        printf "%b Health Check Progress (Attempt %d/%d)\n" "${BLUE}üîç${NC}" $((attempt+1)) "$max_attempts"
        
        # Display current status for all services
        for service in "${services[@]}"; do
            local status
            status=$(get_container_status "$service")
            display_service_status "$service" "$status"
            
            if [[ "$status" == "healthy" || "$status" == "running" ]]; then
                ((healthy_count++))
            else
                all_healthy=false
            fi
        done
        
        # Show progress
        printf "   %b Progress: %d/%d services ready\n" "${CYAN}üìà${NC}" "$healthy_count" "$total_count"
        
        # Check if all services are ready
        if [[ "$all_healthy" == true ]]; then
            printf "\n"
            printf "%b All services are ready and operational!\n" "${GREEN}üéâ${NC}"
            return 0
        fi
        
        sleep 1
        ((attempt++))
    done
    
    printf "\n"
    printf "%b Timeout: Not all services became healthy within expected time\n" "${RED}‚ö†Ô∏è${NC}"
    printf "%b Services may still be initializing. Check status with: docker ps\n" "${YELLOW}üí°${NC}"
    return 1
}
#!/bin/bash

# BlueSpice Shared Services Management
# Manages shared services like database, cache, search, etc.

set -euo pipefail

# Script directory and configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GLOBAL_ENV="${SCRIPT_DIR}/.global.env"
SHARED_ENV="${SCRIPT_DIR}/shared/.shared.env"

# Default values
EDITION="free"
VERSION="5.1"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Source environment files
source_environment() {
    # Source global environment
    if [[ -f "$GLOBAL_ENV" ]]; then
        source "$GLOBAL_ENV"
    fi
    
    # Source shared environment
    if [[ -f "$SHARED_ENV" ]]; then
        source "$SHARED_ENV"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Warning: Shared environment file not found: $SHARED_ENV${NC}"
        echo -e "${YELLOW}üí° Run './shared/generate-passwords' first${NC}"
    fi
}

# Progress indicator
show_progress() {
    local message="$1"
    local duration="${2:-3}"
    
    echo -ne "${BLUE}üîÑ $message"
    for ((i=0; i<duration; i++)); do
        sleep 1
        echo -ne "."
    done
    echo -e " ${GREEN}Done${NC}"
}

# Display service status with colors and icons
# Display service status with Docker Compose style formatting
display_service_status() {
    local service_name="$1"
    local status="$2"
    local uptime=""
    
    # Get container uptime if it exists
    if docker inspect "$service_name" >/dev/null 2>&1; then
        uptime=$(docker inspect --format='{{.State.StartedAt}}' "$service_name" 2>/dev/null | xargs -I {} date -d {} +%s 2>/dev/null || echo "")
        if [[ -n "$uptime" ]]; then
            local current_time=$(date +%s)
            local elapsed=$((current_time - uptime))
            if [[ $elapsed -lt 60 ]]; then
                uptime="${elapsed}s"
            elif [[ $elapsed -lt 3600 ]]; then
                uptime="$((elapsed / 60))m"
            else
                uptime="$((elapsed / 3600))h"
            fi
        else
            uptime="0s"
        fi
    fi
    
    # Format like Docker Compose: " ‚úî Container service-name                        Status                                                                          timing"
    case "$status" in
        "starting")
            printf " %b %-35s %b %*s %s\n" \
                "${YELLOW}‚†ø${NC}" "Container $service_name" "${YELLOW}Starting${NC}" 100 "" "$uptime"
            ;;
        "healthy")
            printf " %b %-35s %b %*s %s\n" \
                "${GREEN}‚úî${NC}" "Container $service_name" "${GREEN}Healthy${NC}" 101 "" "$uptime"
            ;;
        "unhealthy")
            printf " %b %-35s %b %*s %s\n" \
                "${RED}‚úó${NC}" "Container $service_name" "${RED}Unhealthy${NC}" 99 "" "$uptime"
            ;;
        "running")
            printf " %b %-35s %b %*s %s\n" \
                "${GREEN}‚úî${NC}" "Container $service_name" "${GREEN}Running${NC}" 101 "" "$uptime"
            ;;
        "stopped")
            printf " %b %-35s %b %*s %s\n" \
                "${RED}‚èπÔ∏è${NC}" "Container $service_name" "${RED}Stopped${NC}" 101 "" "$uptime"
            ;;
        "not_found")
            printf " %b %-35s %b %*s %s\n" \
                "${PURPLE}‚ùì${NC}" "Container $service_name" "${PURPLE}Not Found${NC}" 98 "" ""
            ;;
        *)
            printf " %b %-35s %b %*s %s\n" \
                "${PURPLE}‚ùî${NC}" "Container $service_name" "${PURPLE}$status${NC}" $((107 - ${#status})) "" "$uptime"
            ;;
    esac
}

# Get container status
get_container_status() {
    local container_name="$1"
    local status
    local health
    
    # Suppress all docker command output
    status=$(docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null || echo "")
    health=$(docker inspect --format='{{.State.Health.Status}}' "$container_name" 2>/dev/null || echo "")
    
    if [[ -z "$status" ]]; then
        echo "not_found"
    elif [[ "$status" == "running" ]]; then
        if [[ "$health" == "healthy" ]]; then
            echo "healthy"
        elif [[ "$health" == "starting" ]]; then
            echo "starting"
        elif [[ "$health" == "unhealthy" ]]; then
            echo "unhealthy"
        else
            echo "running"
        fi
    else
        echo "$status"
    fi
}

# Monitor services with clean status updates
# Monitor services with exact Docker Compose format
monitor_services_startup() {
    local services=("$@")
    local max_attempts=60
    local attempt=0
    
    while [[ $attempt -lt $max_attempts ]]; do
        local healthy_count=0
        local total_count=${#services[@]}
        
        # Clear previous output if this isn't the first attempt
        if [[ $attempt -gt 0 ]]; then
            # Clear the exact number of lines we printed
            for ((i=0; i<${#services[@]}+1; i++)); do
                printf "\033[A\033[K"
            done
        fi
        
        # Count healthy/running services
        for service in "${services[@]}"; do
            local status
            status=$(get_container_status "$service")
            if [[ "$status" == "healthy" || "$status" == "running" ]]; then
                ((healthy_count++))
            fi
        done
        
        # Print header exactly like Docker Compose
        printf "\n[+] Running %d/%d\n" "$healthy_count" "$total_count"
        
        # Print each service exactly like Docker Compose
        for service in "${services[@]}"; do
            local status
            status=$(get_container_status "$service")
            
            # Get elapsed time since container started
            local elapsed=""
            if docker inspect "$service" >/dev/null 2>&1; then
                local start_time
                start_time=$(docker inspect --format='{{.State.StartedAt}}' "$service" 2>/dev/null | xargs -I {} date -d {} +%s 2>/dev/null || echo "")
                if [[ -n "$start_time" ]]; then
                    local current_time=$(date +%s)
                    local diff=$((current_time - start_time))
                    if [[ $diff -lt 10 ]]; then
                        elapsed="${diff}.0s"
                    else
                        elapsed="${diff}s"
                    fi
                else
                    elapsed="0.0s"
                fi
            else
                elapsed="0.0s"
            fi
            
            # Format exactly like Docker Compose initialization
            case "$status" in
                "healthy"|"running")
                    printf " ‚úî Container %-35s %s %*s %s\n" \
                        "$service" "Healthy" 100 "" "$elapsed"
                    ;;
                "starting")
                    printf " ‚†ã Container %-35s %s %*s %s\n" \
                        "$service" "Starting" 99 "" "$elapsed"
                    ;;
                *)
                    printf " ‚úó Container %-35s %s %*s %s\n" \
                        "$service" "$status" $((107 - ${#status})) "" "$elapsed"
                    ;;
            esac
        done
        
        # Check if all services are ready
        if [[ $healthy_count -eq $total_count ]]; then
            return 0
        fi
        
        # Docker Compose updates very fast
        sleep 0.5
        ((attempt++))
    done
    
    return 1
}

# Check Docker login for pro/farm editions
check_docker_login() {
    if [[ "$EDITION" == "pro" || "$EDITION" == "farm" ]]; then
        if ! grep -q 'docker.bluespice.com' "$HOME/.docker/config.json" 2>/dev/null; then
            echo -e "${RED}‚ùå Error: Not logged in to docker.bluespice.com${NC}"
            echo -e "${YELLOW}üí° Please run: docker login docker.bluespice.com${NC}"
            return 1
        fi
    fi
}

# Build compose file arguments
build_compose_args() {
    local -a compose_files=()
    
    # Add persistent data services
    compose_files+=("-f" "docker-compose.persistent-data-services.yml")
    
    # Add stateless services
    compose_files+=("-f" "docker-compose.stateless-services.yml")
    
    # Add proxy configuration
    if [[ -n "${LETSENCRYPT_EMAIL:-}" ]]; then
        compose_files+=("-f" "docker-compose.proxy-letsencrypt.yml")
    fi
    compose_files+=("-f" "docker-compose.proxy.yml")
    
    printf '%s\n' "${compose_files[@]}"
}

# Execute docker compose with output suppression
execute_docker_compose() {
    local command="$1"
    local suppress_output="${2:-true}"
    
    # Build compose arguments
    mapfile -t COMPOSE_FILES < <(build_compose_args)
    
    if [[ "$suppress_output" == "true" ]]; then
        # Suppress all docker compose output except errors, but capture exit code
        if docker compose --env-file .shared.env "${COMPOSE_FILES[@]}" $command >/dev/null 2>&1; then
            return 0
        else
            return 1
        fi
    else
        # Show output (for debugging)
        docker compose --env-file .shared.env "${COMPOSE_FILES[@]}" $command
    fi
}

# Show status of all services
show_services_status() {
    local services=(
        "bluespice-database"
        "bluespice-search" 
        "bluespice-cache"
        "bluespice-proxy"
        "bluespice-pdf"
        "bluespice-formula"
        "bluespice-diagram"
        "bluespice-letsencrypt-service"
    )
    
    echo
    echo -e "${CYAN}üìä Current Service Status${NC}"
    echo -e "${CYAN}========================${NC}"
    echo
    
    for service in "${services[@]}"; do
        # shellcheck disable=SC2155
            local status=$(get_container_status "$service")
        display_service_status "$service" "$status"
    done
    echo
}

# Main execution
main() {
    # Check for help request
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        cat << 'HELP'
BlueSpice Shared Services Manager
=================================

DESCRIPTION:
    Manages shared BlueSpice services including database, search, cache, 
    proxy, and SSL certificate management with a clean, consistent interface.

USAGE:
    ./bluespice-shared-services [COMMAND]

COMMANDS:
    up          Start all shared services (default)
    down        Stop and remove all shared services  
    status      Show status of all shared services
    --help, -h  Show this help message

EXAMPLES:
    ./bluespice-shared-services up
    ./bluespice-shared-services down
    ./bluespice-shared-services status

SERVICES MANAGED:
    - bluespice-database       MariaDB database server
    - bluespice-search         OpenSearch for wiki search  
    - bluespice-cache          Memcached for performance
    - bluespice-proxy          Nginx reverse proxy
    - bluespice-pdf            PDF generation service
    - bluespice-formula        Mathematical formula rendering
    - bluespice-diagram        Diagram generation
    - bluespice-letsencrypt    SSL certificate management

For more information, visit: https://bluespice.com/
HELP
        exit 0
    fi
    
    # Set command (default to 'up' if no arguments)
    local COMMAND="${1:-up}"
    
    # Handle 'up -d' as a single command
    if [[ "$COMMAND" == "up" ]]; then
        COMMAND="up -d"
    fi
    
    # Header
    echo -e ""
    echo -e "${CYAN}BlueSpice Shared Services Manager${NC}"
    echo -e "${CYAN}=================================${NC}"
    echo
    
    # Handle status command separately
    if [[ "$1" == "status" ]]; then
        cd "${SCRIPT_DIR}/shared"
        source_environment
        show_services_status
        cd "${SCRIPT_DIR}"
        return 0
    fi
    
    # Change to shared directory
    cd "${SCRIPT_DIR}/shared"
    
    # Source environment
    source_environment
    
    # Check Docker login if needed
    check_docker_login
    
    # Export configuration
    export EDITION VERSION
    
    # Execute command based on type
    case "$COMMAND" in
        "up -d")
            echo -e ""
            echo -e "${BLUE}üöÄ Starting BlueSpice Shared Services${NC}"
            echo -e "${BLUE}====================================${NC}"
            echo
            show_progress "Initializing containers" 2
            
            # Temporarily disable exit on error for this command
            set +e
            execute_docker_compose "$COMMAND" true
            local exit_code=$?
            set -e
            
            if [[ $exit_code -eq 0 ]]; then
                echo -e "${GREEN}‚úÖ Containers launched successfully${NC}"
                
                # Monitor services startup
                local core_services=(
                    "bluespice-database"
                    "bluespice-search" 
                    "bluespice-cache"
                    "bluespice-proxy"
                )
                
                if monitor_services_startup "${core_services[@]}"; then
                    echo
                    echo -e "${GREEN}üéâ BlueSpice Shared Services are ready!${NC}"
                    echo -e "${CYAN}üí° Use './bluespice-shared-services status' to check service status${NC}"
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Some services may still be initializing${NC}"
                    echo -e "${CYAN}üí° Use 'docker logs <service-name>' to check individual service logs${NC}"
                fi
            else
                echo -e "${RED}‚ùå Failed to start shared services${NC}"
                exit 1
            fi
            ;;
            
        "down")
            echo -e "${YELLOW}üõë Stopping BlueSpice Shared Services${NC}"
            echo -e "${YELLOW}====================================${NC}"
            echo
            show_progress "Stopping containers" 2
            
            if execute_docker_compose "$COMMAND" true; then
                echo -e "${GREEN}‚úÖ Shared services stopped successfully${NC}"
            else
                echo -e "${RED}‚ùå Failed to stop shared services${NC}"
                exit 1
            fi
            ;;
            
        *)
            echo -e "${RED}‚ùå Unknown command: $COMMAND${NC}"
            echo -e "${CYAN}üí° Use --help for available commands${NC}"
            exit 1
            ;;
    esac
    
    echo
    echo -e "${GREEN}‚úÖ Operation completed successfully${NC}"
    
    # Change back to original directory
    cd "${SCRIPT_DIR}"
}

# Run main function
main "$@"
